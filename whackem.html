<!doctype html> 
<html lang="en"> 
<head> 
	<meta charset="UTF-8" />
    <title>Whackem</title>
	<script type="text/javascript" src="js/phaser.min.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">
var game = new Phaser.Game(800, 600, Phaser.AUTO, 'test', null, false, false);

var BasicGame = function (game) {};

BasicGame.Boot = function (game) {};

var gameSettings;
var timer, timerEvent, text;
var timeText;
var risers = [];
var riserY = [];
var riserStatus = [];
var hitEffects;
var hitAreas;
var moles;

BasicGame.Boot.prototype = {
    preload: function () {
		game.load.json('gamesettings', 'assets/gamesettings.json');
		game.load.image('background', 'assets/default/bg.png');
		game.load.image('char', 'assets/default/char.png');
		game.load.image('hit', 'assets/default/hit.png');
		game.load.image('hole', 'assets/default/hole.png');
		game.load.image('curtain', 'assets/default/curtain.png');
    },
   create: function () {
		gameSettings = game.cache.getJSON('gamesettings');
		
		game.physics.startSystem(Phaser.Physics.ARCADE);
	
	    //  A simple background for our game
		game.add.sprite(0, 0, 'background');
					
		stage = game.add.group();
		stage.enableBody = true;
		moles = game.add.group();
		moles.enableBody = true;
		
		stage.add(moles);
		
		var holeStartPointX = parseInt(gameSettings.holeStartPointX);
		var holeStartPointY = parseInt(gameSettings.holeStartPointY);
		var holeSpacingX = parseInt(gameSettings.holeSpacingX);
		var holeSpacingY = parseInt(gameSettings.holeSpecingY);
		var molePop = parseInt(gameSettings.molePopulation);
		var molePerRow = parseInt(gameSettings.molePerRow);
		var row = 0;
		var inRow = 0;
		
		//Create moles
		for (i = 0; i < (molePop); i++) { 
			var xPos = parseInt(holeStartPointX) + ((i >= molePerRow ? (i - (molePerRow)): i) * parseInt(holeSpacingX));
			hole1 = stage.create(xPos, parseInt(holeStartPointY) + (row * parseInt(holeSpacingY)), 'hole');
			hole1.body.immovable = true;
			
			mole = stage.create(xPos, parseInt(holeStartPointY) + (row * parseInt(holeSpacingY)) + 20, 'char');
			mole.body.moves = true;
			mole.inputEnabled = true;
			mole.events.onInputDown.add(this.onCharClicked, this);
			mole.input.priorityID = 0 + row;
			mole.moleNo = i + 1;
		
			curtain1 = stage.create(xPos, parseInt(holeStartPointY) + (row * parseInt(holeSpacingY)) + 20, 'curtain');
			curtain1.body.immovable = true;
			curtain1.inputEnabled = true;
			curtain1.events.onInputDown.add(this.onCurtainClicked, this);
			curtain1.input.priorityID = 1 + row;			
			
			inRow = inRow + 1;
			if(inRow == molePerRow){
				row = row + 1;
				inRow = 0;
			}
		}
		
		//  The score
		timeText = game.add.text(16, 16, '00', gameSettings.font);
		
		hitAreas = game.add.group();
		hitAreas.enableBody = true;
		
		hitEffects = game.add.group();
		hitEffects.enableBody = true;
		
		var hitEffect;

		game.input.onTap.add(function(pointer) {
		  hitEffect = hitEffects.create(pointer.position.x - 30.5, pointer.position.y - 30.5, 'hit');
		  hitEffect.body.immovable = true;		  
		  hitEffect.scale.setTo(0.5, 0.5);
		  hitEffect.alpha =  hitEffect.alpha - 0.5;
		  
		  hit = hitAreas.create(pointer.position.x - 15.25, pointer.position.y - 15.25, 'hit');
		  hit.body.immovable = true;		  
		  hit.scale.setTo(0.25, 0.25);
		  hit.alpha =  0;
		});
		
		while(risers.length < parseInt(gameSettings.risers)){
			this.pickChar();
		}
	
    },
    update: function () {
	    game.physics.arcade.collide(hitAreas, stage, this.onHit);
		var riserIndex;
		stage.forEach(function(riser) {			
			if(!(typeof riser.moleNo === "undefined")){			
				if(risers.indexOf(riser.moleNo) > -1) {
					riserIndex = risers.indexOf(riser.moleNo);						
					if(Math.round(riser.position.y) <= Math.round((riserY[riserIndex] - 130)) && riserStatus[riserIndex] == 'rising'){
						this.hideChar(riser.moleNo);
					}
					else if(Math.round(riser.position.y) >= Math.round((riserY[riserIndex])) && riserStatus[riserIndex]  == 'hiding'){
						riser.body.velocity.y = 0;
						if (riserIndex > -1) {
							//riser.position.y = parseInt(riserY[riserIndex]);
							risers.splice(riserIndex, 1);
							riserY.splice(riserIndex, 1);
							riserStatus.splice(riserIndex, 1);
							this.pickChar();
						}
						
					}
				}
			}
		}, this);
		hitEffects.forEach(function(item) {	
			if(!(typeof item === "undefined")){
				var oldWidth = item.width;
				 
				item.alpha = item.alpha - 0.046;			
				item.scale.setTo(item.scale.x * 1.05, item.scale.y * 1.05);
				item.position.x = item.position.x - ((item.width - oldWidth)/2);
				item.position.y = item.position.y - ((item.width - oldWidth)/2);
				
				if (item.alpha <= 0)
				{
					hitEffects.remove(item);
					item.destroy();
					
					hitAreas.forEach(function(item) {	
						if(!(typeof item === "undefined")){
							hitAreas.remove(item);
							item.destroy();
						}
					});
				}
				
			}			
		});

    },
    render: function () {	
		//timeText.text = riserY + " --- " + riser.position.y;
    },
	pickChar: function() {
		var rand = Math.floor(Math.random() * 6) + 1;
		var speed = Math.floor(Math.random() * parseInt(gameSettings.moveSpeedMax)) + 71;
		while(risers.indexOf(rand) > -1){
			rand = Math.floor(Math.random() * 6) + 1;
		}
		var charx;
		stage.forEach(function(enemy) {
			if(enemy.moleNo == rand) {  
				charx = enemy;  
			}
		}, this);
		risers.push(rand);
		charx.body.velocity.y = -1*speed;
		charx.speed=speed;
		riserY.push(charx.position.y);
		riserStatus.push('rising');
		return charx;
	},
	hideChar: function(moleNo){
		var ind = risers.indexOf(moleNo);	
		stage.forEach(function(mole) {
			if(mole.moleNo == moleNo) {  
				mole.body.velocity.y = mole.speed;
				riserStatus[ind] = 'hiding';  
			}
		}, this);

	},
	onCharClicked: function(charx){
		hitAreas.forEach(function(item) {	
			if(!(typeof item === "undefined")){
				hitAreas.remove(item);
				item.destroy();
			}
		});		
		
		status = 'hiding';
		charx.body.velocity.y = 50;
		
		timeText.text = parseInt(timeText.text) + parseInt(gameSettings.pointsPerHit));
		this.winConCheck();
	},
	winConCheck: function(){
		if(parseInt(timeText.text) >= parseInt(gameSettings.winWhen)){
			timeText.text = "You win!!!";
			this.onWin();
		}
	},
	onCurtainClicked: function(charx){

	},
	onWin: function(){
		//Bryan do your thing
	}
};

game.state.add('Boot', BasicGame.Boot);
game.state.start('Boot');

</script>

</body>
</html>